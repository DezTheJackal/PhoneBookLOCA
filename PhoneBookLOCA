#!/usr/bin/env python3
"""
PhoneBookLOCA v2.1 - Professional OSINT Intelligence Platform
Enhanced with Law Enforcement Geolocation Tools

Created by: DezTheJackal
v1.1: 0xb0rn3 | oxbv1
v2.0: 0xb0rn3 | oxbv1
v2.1 Law Enforcement Geolocation: DezTheJackal

New in v2.1 (by DezTheJackal):
- Enhanced geolocation with maximum legal precision
- Law enforcement investigation interface
- Professional report exports (JSON, CSV, HTML)
- Case tracking and management
- Cell tower proximity analysis
- Missing persons investigation tools
"""

import sys
import json
import csv
import os
import webbrowser
import sqlite3
import math
import argparse
from typing import Dict, Optional, Tuple, List
from datetime import datetime
from pathlib import Path

try:
    import phonenumbers
    from phonenumbers import geocoder, carrier, timezone
except ImportError:
    print("\n[!] Error: 'phonenumbers' module not found")
    print("[*] Install with: pip3 install phonenumbers requests")
    sys.exit(1)

# Rich UI (optional)
try:
    from rich.console import Console
    from rich.panel import Panel
    RICH_AVAILABLE = True
    console = Console()
except ImportError:
    RICH_AVAILABLE = False
    console = None


class Colors:
    RED = '\033[91m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    BOLD = '\033[1m'
    RESET = '\033[0m'


class EnhancedGeolocation:
    """Enhanced Geolocation Engine - Maximum legal precision"""
    
    def __init__(self, db_conn):
        self.conn = db_conn
        self.setup_schemas()
        self.load_databases()
    
    def setup_schemas(self):
        """Create geolocation tables"""
        cursor = self.conn.cursor()
        
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS area_code_mapping (
                area_code TEXT, exchange TEXT, city TEXT, state TEXT, county TEXT,
                latitude REAL, longitude REAL, population INTEGER, timezone TEXT,
                PRIMARY KEY (area_code, exchange)
            )
        ''')
        
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS cell_towers (
                tower_id TEXT PRIMARY KEY, carrier TEXT,
                latitude REAL, longitude REAL, range_km REAL,
                technology TEXT, area_code TEXT, city TEXT, state TEXT
            )
        ''')
        
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS geolocation_cache (
                number TEXT PRIMARY KEY, precision_level TEXT,
                country TEXT, state TEXT, city TEXT, county TEXT,
                latitude REAL, longitude REAL, radius_km REAL,
                confidence REAL, data_sources TEXT,
                last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS le_cases (
                case_id INTEGER PRIMARY KEY AUTOINCREMENT,
                case_number TEXT UNIQUE, number TEXT, officer_name TEXT,
                agency TEXT, case_type TEXT, priority TEXT,
                created_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                status TEXT, notes TEXT
            )
        ''')
        
        self.conn.commit()
    
    def load_databases(self):
        """Load area code and cell tower databases"""
        cursor = self.conn.cursor()
        
        # Check if already loaded
        cursor.execute('SELECT COUNT(*) as count FROM area_code_mapping')
        if cursor.fetchone()['count'] > 0:
            return
        
        # Major US area codes with accurate coordinates
        area_codes = [
            ('415', '555', 'San Francisco', 'CA', 'San Francisco', 37.7749, -122.4194, 881549, 'America/Los_Angeles'),
            ('212', '555', 'New York', 'NY', 'New York', 40.7128, -74.0060, 8336817, 'America/New_York'),
            ('310', '555', 'Los Angeles', 'CA', 'Los Angeles', 34.0522, -118.2437, 3979576, 'America/Los_Angeles'),
            ('312', '555', 'Chicago', 'IL', 'Cook', 41.8781, -87.6298, 2693976, 'America/Chicago'),
            ('713', '555', 'Houston', 'TX', 'Harris', 29.7604, -95.3698, 2320268, 'America/Chicago'),
            ('480', '555', 'Phoenix', 'AZ', 'Maricopa', 33.4484, -112.0740, 1680992, 'America/Phoenix'),
            ('215', '555', 'Philadelphia', 'PA', 'Philadelphia', 39.9526, -75.1652, 1584064, 'America/New_York'),
            ('619', '555', 'San Diego', 'CA', 'San Diego', 32.7157, -117.1611, 1423851, 'America/Los_Angeles'),
            ('214', '555', 'Dallas', 'TX', 'Dallas', 32.7767, -96.7970, 1343573, 'America/Chicago'),
            ('206', '555', 'Seattle', 'WA', 'King', 47.6062, -122.3321, 753675, 'America/Los_Angeles'),
        ]
        
        cursor.executemany('''
            INSERT OR IGNORE INTO area_code_mapping 
            (area_code, exchange, city, state, county, latitude, longitude, population, timezone)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        ''', area_codes)
        
        # Sample cell towers
        towers = [
            ('tower_sf_001', 'Verizon Wireless', 37.7749, -122.4194, 5.0, '5G,LTE', '415', 'San Francisco', 'CA'),
            ('tower_nyc_001', 'Verizon Wireless', 40.7128, -74.0060, 5.0, '5G,LTE', '212', 'New York', 'NY'),
            ('tower_la_001', 'AT&T', 34.0522, -118.2437, 5.0, '5G,LTE', '310', 'Los Angeles', 'CA'),
        ]
        
        cursor.executemany('''
            INSERT OR IGNORE INTO cell_towers
            (tower_id, carrier, latitude, longitude, range_km, technology, area_code, city, state)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        ''', towers)
        
        self.conn.commit()
    
    def get_enhanced_location(self, number: str, parsed: phonenumbers.PhoneNumber) -> Dict:
        """Get maximum precision location"""
        
        # Check cache
        cached = self._get_cached(number)
        if cached:
            cached['from_cache'] = True
            return cached
        
        location_data = {
            'number': number,
            'timestamp': datetime.now().isoformat(),
            'precision_level': 'unknown',
            'confidence': 0.0,
            'coordinates': None,
            'radius_km': None,
            'address': {},
            'sources_used': [],
            'cell_towers_nearby': [],
            'legal_notice': 'Public data only - For real-time tracking, obtain legal warrant'
        }
        
        # Basic geography
        location = geocoder.description_for_number(parsed, "en")
        parts = location.split(',') if location else []
        
        location_data['address'] = {
            'country': phonenumbers.region_code_for_number(parsed) or 'Unknown',
            'region': location or 'Unknown',
            'city': parts[0].strip() if len(parts) > 0 else 'Unknown',
            'state': parts[1].strip() if len(parts) > 1 else 'Unknown',
        }
        location_data['sources_used'].append('phonenumbers_lib')
        
        # Area code analysis
        if parsed.country_code == 1:
            area_data = self._analyze_area_code(parsed)
            if area_data:
                location_data['address'].update(area_data['address'])
                location_data['coordinates'] = area_data['coordinates']
                location_data['precision_level'] = area_data['precision']
                location_data['radius_km'] = area_data['radius_km']
                location_data['confidence'] = area_data['confidence']
                location_data['sources_used'].append('area_code_database')
        
        # Cell tower analysis
        if location_data.get('coordinates'):
            towers = self._find_nearby_towers(
                location_data['coordinates']['latitude'],
                location_data['coordinates']['longitude'],
                carrier.name_for_number(parsed, "en")
            )
            if towers:
                location_data['cell_towers_nearby'] = towers
                location_data['sources_used'].append('cell_tower_database')
        
        # Cache results
        self._cache_location(number, location_data)
        
        return location_data
    
    def _analyze_area_code(self, parsed: phonenumbers.PhoneNumber) -> Optional[Dict]:
        """Analyze area code for location"""
        national_number = str(parsed.national_number)
        if len(national_number) < 6:
            return None
        
        area_code = national_number[:3]
        exchange = national_number[3:6]
        
        cursor = self.conn.cursor()
        
        # Try exact match
        cursor.execute('''
            SELECT * FROM area_code_mapping 
            WHERE area_code = ? AND exchange = ?
        ''', (area_code, exchange))
        
        result = cursor.fetchone()
        
        if result:
            return {
                'address': {
                    'city': result['city'],
                    'state': result['state'],
                    'county': result['county'],
                    'timezone': result['timezone']
                },
                'coordinates': {
                    'latitude': result['latitude'],
                    'longitude': result['longitude']
                },
                'precision': 'exchange',
                'radius_km': 5.0,
                'confidence': 0.8
            }
        
        # Fallback to area code
        cursor.execute('''
            SELECT * FROM area_code_mapping 
            WHERE area_code = ? LIMIT 1
        ''', (area_code,))
        
        result = cursor.fetchone()
        
        if result:
            return {
                'address': {
                    'city': result['city'],
                    'state': result['state'],
                    'county': result['county'],
                    'timezone': result['timezone']
                },
                'coordinates': {
                    'latitude': result['latitude'],
                    'longitude': result['longitude']
                },
                'precision': 'area_code',
                'radius_km': 50.0,
                'confidence': 0.6
            }
        
        return None
    
    def _find_nearby_towers(self, lat: float, lon: float, carrier_name: str) -> List[Dict]:
        """Find nearby cell towers"""
        cursor = self.conn.cursor()
        
        cursor.execute('''
            SELECT *, 
                ((latitude - ?) * (latitude - ?) + 
                 (longitude - ?) * (longitude - ?)) as dist
            FROM cell_towers
            WHERE carrier LIKE ?
            ORDER BY dist LIMIT 5
        ''', (lat, lat, lon, lon, f'%{carrier_name}%'))
        
        towers = []
        for row in cursor.fetchall():
            distance_km = self._calculate_distance(lat, lon, row['latitude'], row['longitude'])
            towers.append({
                'tower_id': row['tower_id'],
                'latitude': row['latitude'],
                'longitude': row['longitude'],
                'distance_km': round(distance_km, 2),
                'range_km': row['range_km'],
                'technology': row['technology']
            })
        
        return towers
    
    def _calculate_distance(self, lat1: float, lon1: float, lat2: float, lon2: float) -> float:
        """Haversine distance formula"""
        R = 6371
        lat1_rad = math.radians(lat1)
        lat2_rad = math.radians(lat2)
        delta_lat = math.radians(lat2 - lat1)
        delta_lon = math.radians(lon2 - lon1)
        
        a = (math.sin(delta_lat / 2) ** 2 + 
             math.cos(lat1_rad) * math.cos(lat2_rad) * 
             math.sin(delta_lon / 2) ** 2)
        c = 2 * math.asin(math.sqrt(a))
        
        return R * c
    
    def _get_cached(self, number: str) -> Optional[Dict]:
        """Get cached geolocation"""
        cursor = self.conn.cursor()
        
        cursor.execute('''
            SELECT * FROM geolocation_cache
            WHERE number = ? AND
                  datetime(last_updated, '+7 days') > datetime('now')
        ''', (number,))
        
        result = cursor.fetchone()
        
        if result:
            return {
                'number': result['number'],
                'precision_level': result['precision_level'],
                'confidence': result['confidence'],
                'coordinates': {
                    'latitude': result['latitude'],
                    'longitude': result['longitude']
                } if result['latitude'] else None,
                'radius_km': result['radius_km'],
                'address': {
                    'country': result['country'],
                    'state': result['state'],
                    'city': result['city'],
                    'county': result['county']
                },
                'sources_used': result['data_sources'].split(',') if result['data_sources'] else []
            }
        
        return None
    
    def _cache_location(self, number: str, location_data: Dict):
        """Cache location data"""
        cursor = self.conn.cursor()
        
        coords = location_data.get('coordinates', {})
        address = location_data.get('address', {})
        
        cursor.execute('''
            INSERT OR REPLACE INTO geolocation_cache
            (number, precision_level, country, state, city, county, 
             latitude, longitude, radius_km, confidence, data_sources)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        ''', (
            number,
            location_data.get('precision_level'),
            address.get('country'),
            address.get('state'),
            address.get('city'),
            address.get('county'),
            coords.get('latitude') if coords else None,
            coords.get('longitude') if coords else None,
            location_data.get('radius_km'),
            location_data.get('confidence', 0.0),
            ','.join(location_data.get('sources_used', []))
        ))
        
        self.conn.commit()
    
    def create_le_case(self, case_number: str, number: str, officer_name: str,
                      agency: str, case_type: str, priority: str) -> int:
        """Create law enforcement case"""
        cursor = self.conn.cursor()
        
        cursor.execute('''
            INSERT INTO le_cases 
            (case_number, number, officer_name, agency, case_type, priority, status)
            VALUES (?, ?, ?, ?, ?, ?, 'active')
        ''', (case_number, number, officer_name, agency, case_type, priority))
        
        self.conn.commit()
        return cursor.lastrowid
    
    def export_le_report(self, number: str, case_number: str, 
                        officer_name: str, agency: str, location_data: Dict) -> Dict:
        """Generate law enforcement report"""
        
        parsed = phonenumbers.parse(number, None)
        
        report = {
            'case_information': {
                'case_number': case_number,
                'requesting_officer': officer_name,
                'agency': agency,
                'report_generated': datetime.now().isoformat(),
                'tool_version': 'PhoneBookLOCA v2.1'
            },
            'legal_disclaimer': {
                'notice': 'This report contains only publicly available data',
                'limitations': [
                    'Coordinates are approximate, not real-time GPS',
                    'Based on area code/exchange assignment',
                    'Number may have been ported',
                    'For precise tracking, obtain warrant and contact carrier'
                ],
                'legal_requirements': [
                    'Real-time location: Requires warrant/court order',
                    'Contact carrier legal compliance with authorization',
                    'Request Call Detail Records (CDR) through legal channels',
                    'Emergency ping available for life-threatening situations'
                ]
            },
            'subject_information': {
                'phone_number': number,
                'formatted_international': phonenumbers.format_number(parsed, phonenumbers.PhoneNumberFormat.INTERNATIONAL),
                'formatted_national': phonenumbers.format_number(parsed, phonenumbers.PhoneNumberFormat.NATIONAL),
                'country_code': f'+{parsed.country_code}',
                'is_valid': phonenumbers.is_valid_number(parsed),
                'carrier': carrier.name_for_number(parsed, "en") or 'Unknown'
            },
            'geolocation_intelligence': location_data,
            'carrier_contacts': self._get_carrier_contacts(carrier.name_for_number(parsed, "en")),
            'map_links': self._generate_map_links(location_data.get('coordinates')),
            'recommendations': self._generate_recommendations(location_data)
        }
        
        return report
    
    def _get_carrier_contacts(self, carrier_name: str) -> Dict:
        """Get carrier legal contacts"""
        contacts = {
            'Verizon Wireless': {
                'legal_compliance': '1-800-451-5242',
                'emergency_24_7': '1-888-483-7200',
                'email': 'lawenforcement@verizonwireless.com'
            },
            'AT&T': {
                'legal_compliance': '1-800-635-6840',
                'emergency_24_7': '1-800-635-6840',
                'email': 'attlegalnotices@att.com'
            },
            'T-Mobile': {
                'legal_compliance': '1-800-937-8997',
                'emergency_24_7': '1-888-987-4500',
                'email': 'legal.requests@t-mobile.com'
            }
        }
        
        for carrier_key, info in contacts.items():
            if carrier_key.lower() in carrier_name.lower():
                return info
        
        return {'carrier': carrier_name, 'notes': 'Contact carrier customer service for legal dept'}
    
    def _generate_map_links(self, coordinates: Optional[Dict]) -> Dict:
        """Generate map links"""
        if not coordinates:
            return {}
        
        lat = coordinates['latitude']
        lon = coordinates['longitude']
        
        return {
            'google_maps': f'https://www.google.com/maps/search/?api=1&query={lat},{lon}',
            'apple_maps': f'http://maps.apple.com/?q={lat},{lon}',
            'coordinates': f'{lat}, {lon}'
        }
    
    def _generate_recommendations(self, location_data: Dict) -> Dict:
        """Generate investigation recommendations"""
        radius = location_data.get('radius_km', 50)
        confidence = location_data.get('confidence', 0.0)
        
        recommendations = {
            'search_area_km2': round(3.14159 * radius * radius, 2),
            'immediate_actions': [],
            'legal_next_steps': [
                'Contact carrier with warrant for real-time location',
                'Request Call Detail Records (CDR)',
                'Consider emergency ping if life-threatening'
            ]
        }
        
        if confidence > 0.7:
            recommendations['immediate_actions'].append('High confidence - focus search in this area')
        else:
            recommendations['immediate_actions'].append('Low confidence - verify with carrier before deployment')
        
        if location_data.get('address', {}).get('city'):
            city = location_data['address']['city']
            recommendations['immediate_actions'].append(f'Contact {city} local police for assistance')
        
        return recommendations


class IntelligenceCache:
    """Basic cache system"""
    
    def __init__(self, db_path: str = None):
        if db_path is None:
            cache_dir = Path.home() / '.phonebookloca'
            cache_dir.mkdir(exist_ok=True)
            db_path = cache_dir / 'intel.db'
        
        self.db_path = db_path
        self.conn = sqlite3.connect(str(db_path))
        self.conn.row_factory = sqlite3.Row
        self.setup_schema()
    
    def setup_schema(self):
        """Create cache table"""
        cursor = self.conn.cursor()
        
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS lookups (
                number TEXT PRIMARY KEY,
                data TEXT,
                last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                lookup_count INTEGER DEFAULT 1
            )
        ''')
        
        self.conn.commit()
    
    def get_cached(self, number: str, max_age_hours: int = 24) -> Optional[Dict]:
        """Get cached data"""
        cursor = self.conn.cursor()
        
        cursor.execute('''
            SELECT data, last_updated, lookup_count
            FROM lookups 
            WHERE number = ? AND 
                  datetime(last_updated, '+' || ? || ' hours') > datetime('now')
        ''', (number, max_age_hours))
        
        result = cursor.fetchone()
        
        if result:
            return {
                'data': json.loads(result['data']),
                'cached': True,
                'lookup_count': result['lookup_count']
            }
        return None
    
    def save_lookup(self, number: str, data: Dict):
        """Save lookup data"""
        cursor = self.conn.cursor()
        
        data_json = json.dumps(data)
        
        cursor.execute('SELECT lookup_count FROM lookups WHERE number = ?', (number,))
        existing = cursor.fetchone()
        
        if existing:
            cursor.execute('''
                UPDATE lookups 
                SET data = ?, last_updated = CURRENT_TIMESTAMP, lookup_count = lookup_count + 1
                WHERE number = ?
            ''', (data_json, number))
        else:
            cursor.execute('''
                INSERT INTO lookups (number, data) VALUES (?, ?)
            ''', (number, data_json))
        
        self.conn.commit()
    
    def close(self):
        """Close connection"""
        self.conn.close()


class ReportExporter:
    """Export reports in multiple formats"""
    
    @staticmethod
    def export_json(report: Dict, output_file: str):
        """Export as JSON"""
        with open(output_file, 'w') as f:
            json.dump(report, f, indent=2)
        return output_file
    
    @staticmethod
    def export_csv(report: Dict, output_file: str):
        """Export as CSV"""
        with open(output_file, 'w', newline='') as f:
            writer = csv.writer(f)
            
            writer.writerow(['PhoneBookLOCA v2.1 - Law Enforcement Report'])
            writer.writerow([])
            
            writer.writerow(['Case Information'])
            for key, value in report['case_information'].items():
                writer.writerow([key.replace('_', ' ').title(), value])
            
            writer.writerow([])
            writer.writerow(['Subject Information'])
            for key, value in report['subject_information'].items():
                writer.writerow([key.replace('_', ' ').title(), value])
            
            writer.writerow([])
            geo = report['geolocation_intelligence']
            writer.writerow(['Geolocation'])
            writer.writerow(['Precision', geo.get('precision_level')])
            writer.writerow(['Confidence', f"{geo.get('confidence', 0):.0%}"])
            
            coords = geo.get('coordinates', {})
            if coords:
                writer.writerow(['Latitude', coords.get('latitude')])
                writer.writerow(['Longitude', coords.get('longitude')])
        
        return output_file
    
    @staticmethod
    def export_html(report: Dict, output_file: str):
        """Export as HTML"""
        html = f"""<!DOCTYPE html>
<html>
<head>
    <title>PhoneBookLOCA v2.1 - LE Report</title>
    <style>
        body {{ font-family: Arial; max-width: 1000px; margin: 20px auto; padding: 20px; }}
        .header {{ background: #1a472a; color: white; padding: 20px; border-radius: 5px; }}
        .section {{ background: white; padding: 20px; margin: 20px 0; border: 1px solid #ddd; border-radius: 5px; }}
        .warning {{ background: #fff3cd; border-left: 4px solid #ffc107; padding: 15px; margin: 10px 0; }}
        table {{ width: 100%; border-collapse: collapse; }}
        td {{ padding: 8px; border-bottom: 1px solid #ddd; }}
        .label {{ font-weight: bold; width: 200px; }}
    </style>
</head>
<body>
    <div class="header">
        <h1>PhoneBookLOCA v2.1 - Law Enforcement Report</h1>
        <p>Generated: {report['case_information']['report_generated']}</p>
    </div>
    
    <div class="section">
        <h2>‚ö†Ô∏è Legal Disclaimer</h2>
        <div class="warning">
            <strong>{report['legal_disclaimer']['notice']}</strong>
        </div>
        <h3>Limitations:</h3>
        <ul>{''.join([f'<li>{item}</li>' for item in report['legal_disclaimer']['limitations']])}</ul>
        <h3>Legal Requirements:</h3>
        <ul>{''.join([f'<li>{item}</li>' for item in report['legal_disclaimer']['legal_requirements']])}</ul>
    </div>
    
    <div class="section">
        <h2>üìã Case Information</h2>
        <table>
            <tr><td class="label">Case Number</td><td>{report['case_information']['case_number']}</td></tr>
            <tr><td class="label">Officer</td><td>{report['case_information']['requesting_officer']}</td></tr>
            <tr><td class="label">Agency</td><td>{report['case_information']['agency']}</td></tr>
        </table>
    </div>
    
    <div class="section">
        <h2>üìû Subject Information</h2>
        <table>
            <tr><td class="label">Phone Number</td><td><strong>{report['subject_information']['phone_number']}</strong></td></tr>
            <tr><td class="label">International Format</td><td>{report['subject_information']['formatted_international']}</td></tr>
            <tr><td class="label">Carrier</td><td>{report['subject_information']['carrier']}</td></tr>
            <tr><td class="label">Valid</td><td>{'‚úì Yes' if report['subject_information']['is_valid'] else '‚úó No'}</td></tr>
        </table>
    </div>
    
    <div class="section">
        <h2>üìç Geolocation Intelligence</h2>
        {ReportExporter._geo_html(report['geolocation_intelligence'])}
    </div>
    
    <div class="section">
        <h2>üìû Carrier Legal Contacts</h2>
        {ReportExporter._carrier_html(report.get('carrier_contacts', {}))}
    </div>
</body>
</html>"""
        
        with open(output_file, 'w') as f:
            f.write(html)
        
        return output_file
    
    @staticmethod
    def _geo_html(geo: Dict) -> str:
        coords = geo.get('coordinates', {})
        address = geo.get('address', {})
        
        html = f"""<table>
            <tr><td class="label">Precision</td><td>{geo.get('precision_level', 'Unknown')}</td></tr>
            <tr><td class="label">Confidence</td><td>{geo.get('confidence', 0):.0%}</td></tr>
            <tr><td class="label">Radius</td><td>¬±{geo.get('radius_km', 'N/A')} km</td></tr>"""
        
        if coords:
            html += f"""<tr><td class="label">Latitude</td><td>{coords.get('latitude'):.6f}</td></tr>
            <tr><td class="label">Longitude</td><td>{coords.get('longitude'):.6f}</td></tr>"""
        
        html += f"""<tr><td class="label">City</td><td>{address.get('city', 'Unknown')}</td></tr>
            <tr><td class="label">County</td><td>{address.get('county', 'Unknown')}</td></tr>
            <tr><td class="label">State</td><td>{address.get('state', 'Unknown')}</td></tr>
        </table>"""
        
        return html
    
    @staticmethod
    def _carrier_html(carrier: Dict) -> str:
        if not carrier:
            return "<p>No carrier information</p>"
        
        html = "<table>"
        for key, value in carrier.items():
            html += f"<tr><td class='label'>{key.replace('_', ' ').title()}</td><td>{value}</td></tr>"
        html += "</table>"
        
        return html


class PhoneIntel:
    """Main intelligence class"""
    
    def __init__(self):
        self.db_cache = IntelligenceCache()
        self.geo_engine = EnhancedGeolocation(self.db_cache.conn)
        self.exporter = ReportExporter()
    
    def print_banner(self):
        """Display banner"""
        if RICH_AVAILABLE:
            banner = Panel.fit(
                "[bold magenta]PhoneBookLOCA v2.1[/bold magenta]\n"
                "[cyan]Professional OSINT Intelligence Platform[/cyan]\n"
                "[yellow]Law Enforcement Edition[/yellow]\n\n"
                "[yellow]Created by:[/yellow] [bold]DezTheJackal[/bold]\n"
                "[yellow]v1.1:[/yellow] 0xb0rn3 | oxbv1\n"
                "[yellow]v2.0:[/yellow] 0xb0rn3 | oxbv1\n"
                "[yellow]v2.1 LE Geolocation:[/yellow] [bold]DezTheJackal[/bold]",
                title="üì± Phone Intelligence",
                border_style="blue"
            )
            console.print("\n", banner, "\n")
        else:
            print("\n" + "="*60)
            print("  PhoneBookLOCA v2.1 - Law Enforcement Edition")
            print("  Created by: DezTheJackal")
            print("  v1.1-v2.0: 0xb0rn3 | oxbv1")
            print("  v2.1 Geolocation: DezTheJackal")
            print("="*60 + "\n")
    
    def validate_phone_number(self, number: str) -> Tuple[bool, Optional[phonenumbers.PhoneNumber], Optional[str]]:
        """Validate phone number"""
        try:
            parsed = phonenumbers.parse(number, None)
            if phonenumbers.is_valid_number(parsed):
                return True, parsed, None
            else:
                return False, None, "Invalid phone number format"
        except phonenumbers.NumberParseException as e:
            return False, None, f"Parse error: {str(e)}"
    
    def lookup_phone_number(self, number: str, enhanced_geo: bool = False, 
                          use_cache: bool = True) -> Optional[Dict]:
        """Perform phone number lookup"""
        
        # Check cache
        if use_cache:
            cached = self.db_cache.get_cached(number)
            if cached:
                print(f"\n[*] Using cached data (lookups: {cached['lookup_count']})")
                result = cached['data']
                result['from_cache'] = True
                self.display_results(result)
                return result
        
        print(f"\n[*] Target: {number}")
        print(f"[*] Initiating trace...\n")
        
        is_valid, parsed, error = self.validate_phone_number(number)
        
        if not is_valid:
            print(f"[!] Error: {error}\n")
            return None
        
        # Basic lookup
        location = geocoder.description_for_number(parsed, "en") or "Unknown"
        carrier_name = carrier.name_for_number(parsed, "en") or "Unknown"
        timezones = timezone.time_zones_for_number(parsed) or ["Unknown"]
        
        results = {
            "timestamp": datetime.now().isoformat(),
            "input": number,
            "valid": True,
            "country_code": f"+{parsed.country_code}",
            "location": location,
            "carrier": carrier_name,
            "type": self._get_number_type(parsed),
            "timezones": timezones,
            "from_cache": False
        }
        
        # Enhanced geolocation
        if enhanced_geo:
            print("[*] Performing enhanced geolocation analysis...")
            geo_data = self.geo_engine.get_enhanced_location(number, parsed)
            results['enhanced_geolocation'] = geo_data
        
        # Save to cache
        self.db_cache.save_lookup(number, results)
        
        # Display results
        self.display_results(results)
        
        return results
    
    def _get_number_type(self, parsed: phonenumbers.PhoneNumber) -> str:
        """Get number type"""
        number_type = phonenumbers.number_type(parsed)
        type_mapping = {
            phonenumbers.PhoneNumberType.FIXED_LINE: "Fixed Line",
            phonenumbers.PhoneNumberType.MOBILE: "Mobile",
            phonenumbers.PhoneNumberType.VOIP: "VoIP",
            phonenumbers.PhoneNumberType.TOLL_FREE: "Toll Free",
            phonenumbers.PhoneNumberType.UNKNOWN: "Unknown"
        }
        return type_mapping.get(number_type, "Unknown")
    
    def display_results(self, results: Dict):
        """Display results"""
        if RICH_AVAILABLE:
            self._display_rich(results)
        else:
            self._display_basic(results)
    
    def _display_rich(self, results: Dict):
        """Display with Rich formatting"""
        basic_info = f"""[cyan]Country:[/cyan] {results.get('location', 'Unknown')} ({results.get('country_code', 'N/A')})
[cyan]Carrier:[/cyan] {results.get('carrier', 'Unknown')}
[cyan]Type:[/cyan] {results.get('type', 'Unknown')}
[cyan]Timezone(s):[/cyan] {', '.join(results.get('timezones', ['Unknown']))}"""
        
        panel = Panel.fit(basic_info, title="üìä Basic Intelligence", border_style="green")
        console.print(panel)
        
        # Enhanced Geolocation
        if "enhanced_geolocation" in results:
            geo = results["enhanced_geolocation"]
            coords = geo.get('coordinates', {})
            address = geo.get('address', {})
            
            geo_info = f"""[cyan]Precision:[/cyan] {geo.get('precision_level', 'Unknown')}
[cyan]Confidence:[/cyan] {geo.get('confidence', 0):.0%}
[cyan]Radius:[/cyan] ¬±{geo.get('radius_km', 'N/A')} km"""
            
            if coords:
                geo_info += f"""

[cyan]Coordinates:[/cyan]
  Lat: {coords.get('latitude'):.6f}
  Lon: {coords.get('longitude'):.6f}"""
            
            geo_info += f"""

[cyan]Location:[/cyan]
  City: {address.get('city', 'Unknown')}
  County: {address.get('county', 'Unknown')}
  State: {address.get('state', 'Unknown')}"""
            
            console.print("\n")
            panel = Panel.fit(geo_info, title="üìç Enhanced Geolocation", border_style="blue")
            console.print(panel)
            
            if geo.get('cell_towers_nearby'):
                console.print(f"\n[cyan]üì° Cell Towers:[/cyan] {len(geo['cell_towers_nearby'])} nearby")
            
            console.print(f"\n[yellow]‚öñÔ∏è  Legal Notice:[/yellow]")
            console.print(f"[dim]{geo.get('legal_notice')}[/dim]")
        
        console.print("\n[green][+][/green] Trace complete\n")
    
    def _display_basic(self, results: Dict):
        """Display with basic formatting"""
        print("[+] Results:")
        print(f"    Country: {results.get('location', 'Unknown')} ({results.get('country_code', 'N/A')})")
        print(f"    Carrier: {results.get('carrier', 'Unknown')}")
        print(f"    Type: {results.get('type', 'Unknown')}")
        print(f"    Timezone(s): {', '.join(results.get('timezones', ['Unknown']))}")
        
        if "enhanced_geolocation" in results:
            geo = results["enhanced_geolocation"]
            print(f"\n[*] Enhanced Geolocation:")
            print(f"    Precision: {geo.get('precision_level')}")
            print(f"    Confidence: {geo.get('confidence', 0):.0%}")
            print(f"    Radius: ¬±{geo.get('radius_km')} km")
            
            coords = geo.get('coordinates', {})
            if coords:
                print(f"    Coordinates: {coords.get('latitude'):.6f}, {coords.get('longitude'):.6f}")
            
            address = geo.get('address', {})
            print(f"    City: {address.get('city')}")
            print(f"    County: {address.get('county')}")
            print(f"    State: {address.get('state')}")
        
        print("\n[+] Trace complete\n")
    
    def law_enforcement_mode(self):
        """Law enforcement investigation mode"""
        self.print_banner()
        
        print("üö® LAW ENFORCEMENT MODE")
        print("Enhanced Geolocation for Missing Persons Investigations\n")
        
        # Gather case info
        case_number = input("Case Number: ").strip()
        officer_name = input("Officer Name: ").strip()
        agency = input("Agency: ").strip()
        case_type = input("Case Type (missing person/investigation): ").strip() or "investigation"
        priority = input("Priority (high/medium/standard): ").strip() or "standard"
        number = input("\nSubject Phone Number: ").strip()
        
        if not all([case_number, officer_name, agency, number]):
            print("\n[!] Error: All fields required\n")
            return
        
        # Create case
        case_id = self.geo_engine.create_le_case(
            case_number, number, officer_name, agency, case_type, priority
        )
        
        print(f"\n[+] Case created: ID {case_id}\n")
        
        # Perform lookup
        results = self.lookup_phone_number(number, enhanced_geo=True)
        
        if not results:
            return
        
        # Generate report
        print("\n" + "="*60)
        print("  Generating Law Enforcement Report")
        print("="*60 + "\n")
        
        parsed = phonenumbers.parse(number, None)
        report = self.geo_engine.export_le_report(
            number, case_number, officer_name, agency,
            results.get('enhanced_geolocation', {})
        )
        
        # Export options
        print("\nExport Options:")
        print("  1) JSON")
        print("  2) CSV")
        print("  3) HTML")
        print("  4) All formats")
        print("  5) Skip")
        
        choice = input("\nSelect [1-5]: ").strip()
        
        if choice != '5':
            output_dir = Path.home() / '.phonebookloca' / 'reports'
            output_dir.mkdir(parents=True, exist_ok=True)
            
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            base = f"LE_Report_{case_number}_{timestamp}"
            
            if choice in ['1', '4']:
                json_file = output_dir / f"{base}.json"
                self.exporter.export_json(report, str(json_file))
                print(f"\n[+] JSON saved: {json_file}")
            
            if choice in ['2', '4']:
                csv_file = output_dir / f"{base}.csv"
                self.exporter.export_csv(report, str(csv_file))
                print(f"[+] CSV saved: {csv_file}")
            
            if choice in ['3', '4']:
                html_file = output_dir / f"{base}.html"
                self.exporter.export_html(report, str(html_file))
                print(f"[+] HTML saved: {html_file}")
                
                if input("\nOpen HTML in browser? [y/N]: ").lower() == 'y':
                    webbrowser.open(f'file://{html_file}')
        
        print("\n[+] Investigation complete\n")
    
    def interactive_mode(self):
        """Interactive mode"""
        self.print_banner()
        
        print("Enter phone numbers to lookup (e.g., +1234567890)")
        print("Commands: 'geo <number>' | 'le-mode' | 'help' | 'quit'\n")
        
        while True:
            try:
                user_input = input("PhoneBook> ").strip()
                
                if user_input.lower() in ['quit', 'exit', 'q']:
                    print("\n[*] Goodbye!\n")
                    break
                
                if user_input.lower() == 'help':
                    self.show_help()
                    continue
                
                if user_input.lower() == 'le-mode':
                    self.law_enforcement_mode()
                    continue
                
                if user_input.lower().startswith('geo '):
                    number = user_input[4:].strip()
                    self.lookup_phone_number(number, enhanced_geo=True)
                    continue
                
                if not user_input:
                    continue
                
                # Standard lookup
                self.lookup_phone_number(user_input)
                
            except KeyboardInterrupt:
                print("\n\n[*] Exiting...\n")
                break
            except Exception as e:
                print(f"\n[!] Error: {str(e)}\n")
        
        self.db_cache.close()
    
    def show_help(self):
        """Show help"""
        print("\nCommands:")
        print("  <number>          - Standard lookup")
        print("  geo <number>      - Enhanced geolocation")
        print("  le-mode          - Law enforcement mode")
        print("  help             - Show this message")
        print("  quit             - Exit")
        print("\nLaw Enforcement Features:")
        print("  ‚Ä¢ Case tracking")
        print("  ‚Ä¢ Professional reports (JSON, CSV, HTML)")
        print("  ‚Ä¢ Enhanced geolocation")
        print("  ‚Ä¢ Cell tower analysis")
        print("  ‚Ä¢ Carrier legal contacts\n")


def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(
        description='PhoneBookLOCA v2.1 - Law Enforcement Edition',
        epilog="""
Examples:
  %(prog)s +14155552671           # Standard lookup
  %(prog)s +14155552671 --geo     # Enhanced geolocation
  %(prog)s --le-mode              # Law enforcement mode
  %(prog)s                        # Interactive mode

v2.1 Law Enforcement Features (by DezTheJackal):
  - Enhanced geolocation (maximum legal precision)
  - Professional report exports
  - Case tracking
  - Cell tower analysis
        """
    )
    
    parser.add_argument('number', nargs='?', help='Phone number')
    parser.add_argument('--geo', action='store_true', help='Enhanced geolocation')
    parser.add_argument('--le-mode', action='store_true', help='Law enforcement mode')
    parser.add_argument('--no-cache', action='store_true', help='Disable cache')
    
    args = parser.parse_args()
    
    intel = PhoneIntel()
    
    # LE mode
    if args.le_mode:
        intel.law_enforcement_mode()
        intel.db_cache.close()
        return
    
    # Single lookup
    if args.number:
        intel.print_banner()
        intel.lookup_phone_number(args.number, enhanced_geo=args.geo, use_cache=not args.no_cache)
        intel.db_cache.close()
        return
    
    # Interactive mode
    intel.interactive_mode()


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n\n[*] Exiting...\n")
        sys.exit(0)
